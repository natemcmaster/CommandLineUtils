<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Arguments </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Arguments ">
      
      
      <link rel="icon" href="../favicon.ico">
      <link rel="stylesheet" href="../public/docfx.min.css">
      <link rel="stylesheet" href="../public/main.css">
      <meta name="docfx:navrel" content="../toc.html">
      <meta name="docfx:tocrel" content="toc.html">
      
      <meta name="docfx:rel" content="../">
      
      
      <meta name="docfx:docurl" content="https://github.com/natemcmaster/CommandLineUtils/blob/main/docs/docs/arguments.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../index.html">
            <img id="logo" class="svg" src="../logo.png" alt="CommandLineUtils">
            CommandLineUtils
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="arguments">
<h1 id="arguments">Arguments</h1>

<p>When a command executes, the raw <code>string[] args</code> value can be separated into two different categories: options and arguments.</p>
<p>Arguments are positional and values are specified based by order.</p>
<p>Options are named and must be specified using a name. Options are covered in <a class="xref" href="options.html">this document.</a></p>
<p>Arguments are represented by the <a class="xref" href="../api/McMaster.Extensions.CommandLineUtils.CommandArgument.html">CommandArgument</a> type.
They have one defining characteristic.</p>
<ul>
<li>Position - the order in which arguments appear on command line (after options have been parsed)</li>
</ul>
<div class="tabGroup" id="tabgroup_1">
<ul role="tablist">
<li role="presentation">
<a href="#tabpanel_1_using-attributes" role="tab" aria-controls="tabpanel_1_using-attributes" data-tab="using-attributes" tabindex="0" aria-selected="true">Using Attributes</a>
</li>
<li role="presentation">
<a href="#tabpanel_1_using-builder-api" role="tab" aria-controls="tabpanel_1_using-builder-api" data-tab="using-builder-api" tabindex="-1">Using Builder API</a>
</li>
</ul>
<section id="tabpanel_1_using-attributes" role="tabpanel" data-tab="using-attributes">

<p><a class="xref" href="../api/McMaster.Extensions.CommandLineUtils.ArgumentAttribute.html">ArgumentAttribute</a> can be used on properties to define arguments.
The argument order must be specified explicitly.</p>
<pre><code class="lang-c#">public class Program
{
    [Argument(0)]
    [Required]
    public string FirstName { get; }

    [Argument(1)]
    public string LastName { get; }  // this one is optional because it doesn't have `[Required]`

    private void OnExecute()
    {
        Console.WriteLine($&quot;Hello {FirstName} {LastName}&quot;);
    }

    public static int Main(string[] args) =&gt; CommandLineApplication.Execute&lt;Program&gt;(args);
}
</code></pre>
</section>
<section id="tabpanel_1_using-builder-api" role="tabpanel" data-tab="using-builder-api" aria-hidden="true" hidden="hidden">

<pre><code class="lang-c#">public class Program
{
    public static int Main(string[] args)
    {
        var app = new CommandLineApplication();

        var firstNameArg = app.Argument(&quot;first name&quot;, &quot;the first name of the person&quot;)
            .IsRequired();
        var lastNameArg = app.Argument(&quot;last name&quot;, &quot;the last name of the person&quot;);

        app.OnExecute(() =&gt;
        {
            Console.WriteLine($&quot;Hello {firstNameArg.Value} {lastNameArg.Value}&quot;);
        });

        return app.Execute(args);
    }
}
</code></pre>
</section>
</div>
<h2 id="variable-numbers-of-arguments">Variable numbers of arguments</h2>
<p>A common scenario is to allow a command line tool to take in a variable number of arguments.
These arguments are collected into a <code>string[]</code> array after all other arguments and options are parsed.</p>
<pre><code>cat -b 123 file1.txt file2.txt file3.txt
</code></pre>
<div class="tabGroup" id="tabgroup_2">
<ul role="tablist">
<li role="presentation">
<a href="#tabpanel_2_using-attributes" role="tab" aria-controls="tabpanel_2_using-attributes" data-tab="using-attributes" tabindex="0" aria-selected="true">Using Attributes</a>
</li>
<li role="presentation">
<a href="#tabpanel_2_using-builder-api" role="tab" aria-controls="tabpanel_2_using-builder-api" data-tab="using-builder-api" tabindex="-1">Using Builder API</a>
</li>
</ul>
<section id="tabpanel_2_using-attributes" role="tabpanel" data-tab="using-attributes">

<p>By default, attribute binding will assume multiple values can be set for properties with the <code>[Argument]</code>
attribute and settable to <code>string[]</code> or <code>IEnumerable&lt;string&gt;</code>.</p>
<pre><code class="lang-c#">public class Program
{
    [Option(&quot;-b&quot;)]
    public int BlankLines { get; }

    [Argument(0)]
    public string[] Files { get; } // = { &quot;file1.txt&quot;, &quot;file2.txt&quot;, &quot;file3.txt&quot; }

    private void OnExecute()
    {
        if (Files != null)
        {
            foreach (var file in Files)
            {
                // do something
            }
        }
    }

    public static int Main(string[] args) =&gt; CommandLineApplication.Execute&lt;Program&gt;(args);
}
</code></pre>
</section>
<section id="tabpanel_2_using-builder-api" role="tabpanel" data-tab="using-builder-api" aria-hidden="true" hidden="hidden">

<p>To enable this, <a class="xref" href="../api/McMaster.Extensions.CommandLineUtils.CommandArgument.html#McMaster_Extensions_CommandLineUtils_CommandArgument_MultipleValues">MultipleValues</a> must be set to true,
and the argument must be the last one specified.</p>
<pre><code class="lang-c#">public class Program
{
    public static int Main(string[] args)
    {
        var app = new CommandLineApplication();
        var blankLines = app.Option&lt;int&gt;(&quot;-b &lt;LINES&gt;&quot;, &quot;Blank lines&quot;, CommandOptionType.SingleValue);
        var files = app.Argument(&quot;Files&quot;, &quot;Files to count&quot;, multipleValues: true);
        app.OnExecute(() =&gt;
        {
            foreach (var file in files.Values)
            {
                // do something
            }
        });
        return app.Execute(args);
    }
}
</code></pre>
</section>
</div>
<h2 id="pass-thru-arguments">Pass-thru arguments</h2>
<p>Another common scenario is to create a command line tool which wraps another tool. These kinds of command lines
need to collect arguments which are passed to the to the tool they wrap. For example, the Unix command <code>time</code>
or the Windows command <code>cmd</code> take some arguments, and pass the rest on to the command they invoke.</p>
<div class="NOTE">
<h5>Note</h5>
<p>Example:</p>
<pre><code>time -l ls -a -l ./
</code></pre>
<p>In this example, <code>-l</code> is an option on <code>time</code>. This starts a timer which then invokes <code>ls</code> with additional arguments.
<code>-l</code> is also an option on <code>ls</code>.</p>
</div>
<p>Normally, unrecognized arguments is an error. You must set <code>UnrecognizedArgumentHandling</code> to <code>StopParsingAndCollect</code> to allow the parser
to collect unrecognized arguments and options.</p>
<h3 id="the-double-dash-convention---">The double-dash convention <code>--</code></h3>
<p>It is common for apps which pass-thru arguments to allow the caller to use <code>--</code> to distinguish between the
options on the parent command and all remaining arguments.</p>
<pre><code>bash -c -- ls -a -l
</code></pre>
<p>In this example, the presence of <code>--</code> forces bash to stop parsing and treat everything after <code>--</code> as an argument
to be passed to the inner command.</p>
<p>The double dash command is enabled by setting <a class="xref" href="../api/McMaster.Extensions.CommandLineUtils.CommandLineApplication.html#McMaster_Extensions_CommandLineUtils_CommandLineApplication_AllowArgumentSeparator">AllowArgumentSeparator</a>.</p>
<div class="tabGroup" id="tabgroup_3">
<ul role="tablist">
<li role="presentation">
<a href="#tabpanel_3_using-attributes" role="tab" aria-controls="tabpanel_3_using-attributes" data-tab="using-attributes" tabindex="0" aria-selected="true">Using Attributes</a>
</li>
<li role="presentation">
<a href="#tabpanel_3_using-builder-api" role="tab" aria-controls="tabpanel_3_using-builder-api" data-tab="using-builder-api" tabindex="-1">Using Builder API</a>
</li>
</ul>
<section id="tabpanel_3_using-attributes" role="tabpanel" data-tab="using-attributes">

<p>By default, attribute binding will set a <code>string[]</code> or <code>IList&lt;string&gt;</code> property named <code>RemainingArguments</code> or <code>RemainingArgs</code>
to include all values. See <a class="xref" href="../api/McMaster.Extensions.CommandLineUtils.Conventions.RemainingArgsPropertyConvention.html">RemainingArgsPropertyConvention</a> for more details.</p>
<pre><code class="lang-csharp" name="Program">using System;
using System.Diagnostics;
using System.Linq;
using McMaster.Extensions.CommandLineUtils;

[Command(
    UnrecognizedArgumentHandling = UnrecognizedArgumentHandling.StopParsingAndCollect,
    AllowArgumentSeparator = true)]
public class Program
{
    public static int Main(string[] args) =&gt; CommandLineApplication.Execute&lt;Program&gt;(args);

    [Option(&quot;-m&quot;, Description = &quot;Show time in milliseconds&quot;)]
    public bool Milliseconds { get; }

    public string[] RemainingArguments { get; } // = { &quot;ls&quot;, &quot;-a&quot;, &quot;-l&quot; }

    private void OnExecute()
    {
        var timer = Stopwatch.StartNew();
        if (RemainingArguments != null &amp;&amp; RemainingArguments.Length &gt; 0)
        {
            var process = new Process
            {
                StartInfo =
                {
                    FileName = RemainingArguments[0],
                    Arguments = ArgumentEscaper.EscapeAndConcatenate(RemainingArguments.Skip(1)),
                }
            };
            process.Start();
            process.WaitForExit();
        }

        timer.Stop();

        if (Milliseconds)
        {
            Console.WriteLine($&quot;Time = {timer.Elapsed.TotalMilliseconds} ms&quot;);
        }
        else
        {
            Console.WriteLine($&quot;Time = {timer.Elapsed.TotalSeconds}s&quot;);
        }
    }
}
</code></pre></section>
<section id="tabpanel_3_using-builder-api" role="tabpanel" data-tab="using-builder-api" aria-hidden="true" hidden="hidden">

<p>When <code>UnrecognizedArgumentHandling</code> is set to <code>Stop</code>,</p>
<pre><code class="lang-csharp" name="Program">using System;
using System.Diagnostics;
using System.Linq;
using McMaster.Extensions.CommandLineUtils;

public class Program
{
    public static int Main(string[] args)
    {
        var app = new CommandLineApplication
        {
            AllowArgumentSeparator = true,
            UnrecognizedArgumentHandling = UnrecognizedArgumentHandling.StopParsingAndCollect,
        };

        var showMilliseconds = app.Option&lt;int&gt;(&quot;-m&quot;, &quot;Show time in milliseconds&quot;, CommandOptionType.NoValue);

        app.OnExecute(() =&gt;
        {
            var timer = Stopwatch.StartNew();
            if (app.RemainingArguments != null &amp;&amp; app.RemainingArguments.Count &gt; 0)
            {
                var process = new Process
                {
                    StartInfo =
                {
                    FileName = app.RemainingArguments[0],
                    Arguments = ArgumentEscaper.EscapeAndConcatenate(app.RemainingArguments.Skip(1)),
                }
                };
                process.Start();
                process.WaitForExit();
            }

            timer.Stop();

            if (showMilliseconds.HasValue())
            {
                Console.WriteLine($&quot;Time = {timer.Elapsed.TotalMilliseconds} ms&quot;);
            }
            else
            {
                Console.WriteLine($&quot;Time = {timer.Elapsed.TotalSeconds}s&quot;);
            }
        });

        return app.Execute(args);
    }
}
</code></pre></section>
</div>

</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/natemcmaster/CommandLineUtils/blob/main/docs/docs/arguments.md/#L1" class="edit-link">Edit this page</a>
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
           <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
        </div>
      </div>
    </footer>
  </body>
</html>
